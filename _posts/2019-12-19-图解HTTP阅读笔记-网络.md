---
layout: post
title: 《图解HTTP》阅读笔记
date: 2019-12-19
categories: 网络
tags: [网络]
author: "Gemicat"
comments: false
---

TCP/IP 按照层次分为：应用层、传输层、网络层、数据链路层

1. 应用层：决定了向用户提供应用服务时通信的活动(dns、fpt、http、https)
2. 传输层：无连接协议 UDP、面向连接的协议 TCP。支付一般使用  TCP，TCP 会保证这个包能够到达目的地，如果不能到达，就会重新发送，直至到达
3. 网络层：IP 协议，里面会有源 IP 地址，即浏览器所在机器的 IP 地址和目标 IP 地址
4. 数据链路层：用来处理连接网络的硬件部分

ARP 协议：通过 IP 地址反查出对应的 MAC 地址

TCP 三次握手(确保数据到达目标)：
1. 发送端发送带SYN标志的数据包给对方；
2. 回传带有SYN/ACK标志数据包确认;
3. 发送端回传 ACK 数据包结束；

DNS：提供域名到 IP 地址间的解析服务

URI(统一资源标识符)

RFC: 制定 HTTP 协议技术标准的文档

http请求方式
1. GET：获取资源(1.0、1.1)；
2. POST：传输实体主体(1.0、1.1)；
3. PUT：传输文件，不带验证机制(1.0、1.1)；
4. HEAD：获取报文头部(1.0、1.1)；
5. DELETE：删除文件，不带验证机制(1.0、1.1)；
6. OPTIONS：询问支持的方法(1.1)；
7. TRACE：查询请求的链路，容易引发XST(跨站追踪)攻击(1.1)
8. CONNECT：要求用隧道协议连接代理(1.1)
9. LINK：建立和资源之间的联系(1.0)
10. UNLINK：断开连接关系(1.0)

在 HTTP/1.1 中，默认所有连接都是持久连接，管线话可以实现请求并行

无状态协议的优点：减少服务器CPU及内存的消耗，使HTTP变得简单，可以被应用在更多场景。


RPC 框架

**Http报文结构：**
1. 报文首部：服务器端或客户端需处理的请求或相应的内容及属性。
2. CR + LF：回车 + 换行。
3. 报文主体：应被发送的数据。

HTTP 状态吗用来表示 HTTP 请求的返回结果，标记服务器端的处理是否正常，通知出现的错误等工作。

**状态码的类别:**
状态码 | 类别 | 原因短语
---|---|---
1XX | 信息性状态码 | 接收的请求正在处理
2XX | 成功状态码 | 请求正常处理完毕
3XX | 重定向状态码 | 需要进行附加操作以完成请求
4XX | 客户端错误状态码 | 服务器无法处理请求
5XX | 服务器错误状态吗 | 服务器处理请求出错


**代理**

代理服务器的基本行为就是接受客户端发送的请求后转发给其他服务器，不会改变请求URI，每次经过代理服务器会追加写入 Via 首部信息。

使用代理服务器的理由：利用缓存技术减少网络带宽的流量，对特定网站访问控制，获取访问日志...

1. 缓存代理：代理转发响应时，缓存代理会将资源副本保存在代理服务器上，当代理再次接受到相同资源则不会从原服务器获取
2. 透明代理：转发请求或响应时，看是否对保存做加工

**网关**

利用网关可以有 HTTP 请求转化为其他协议通信。

**隧道**

确保客户端与服务器进行安全的通信。

HTTP 首部字段重复会根据浏览器有不同而处理逻辑。

4 种 HTTP 首部字段：通用首部字段、请求首部字段、响应首部字段、实体首部字段

**http 的缺点**
1. 通信使用明文，内容可能会被窃听
2. 不验证通信方的身份，因此有可能遭遇伪装
3. 无法验证报文完整性，有可能已遭篡改

https = http + 加密 + 认证 + 完整性保护

https 并非是应用层的一种新的协议，只是 http 通信接口部分用 ssl 和 tls 协议代替而已。

**对称加密 & 分对称加密**

`对称加密` 使用相同的秘钥进行加密，没有安全的方法将秘钥传递给对方。

`非对称加密` 分成公钥和私钥，公钥可以随意发布，私钥只能由自己保管。发送密文的一方使用对方的公钥进行加密处理，对方收到后用自己的私钥进行解密。

`非对称加密` 处理起来比对称加密方式更为复杂，因此效率会低。

`HTTPS` 采用混合加密机制，利用 `非对称加密` 来交换 `对称加密` 的秘钥。

**数字证书**

`非对称加密` 的问题是无法保证公钥是否是真实的，为了解决这个问题，引入了数字证书机制。

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。服务器向机构提出公钥申请，机构验证身份后，会对已申请的公钥做数字签名，并将该公钥放入公钥证书。

服务器会将公钥证书发送给客户端，接到证书的客户端使用认证机关的公钥进行验证，一般浏览器会内部植入常用认证机关的公开密钥。

**HTTPS 通信流程**

1. `[客户端-服务器]`客户端通过发送 Client Hello 报文开始 SSL 通信，包含客户端支持的 SSL 指定版本、加密组件列表(加密算法&秘钥长度等)
1. 服务器可进行 SSL 通信是，会以 Server Hello 报文作为应答，包含 SSL 版本以及加密组件。
1. 之后服务器发送 Certificate 报文，包含公开的秘钥证书。
1. 服务器发送 Server Hello Done 报文通知客户端 SSL 握手协商部分结束。
1. SSL 第一次握手结束后，客户端以 Client Key Exchange 报文作为回应，包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。改报文已用步骤 3 中 的公开秘钥进行加密。
1. 客户端继续发送 Change Cipher Spec 报文，提示服务器在之后的通信中会采用 Pre-master secret 秘钥加密。
1. 客户端发送 Finished 报文，包含链接至今全部报文的整体校验值，服务器进行校验来判断握手是否协商成功。
1. 服务器发送 Change Cipher Spec 报文。
1. 服务器发送 Finished 报文。
1. 当全部的 Finished 报文交换完毕，SSL 链接建立完成，从此处开始应用层协议通信，发送 HTTP 内容。
1. 应用层协议通信，即发送 HTTP 响应。
1. 客户端断开连接，发送 close_notify 报文，在发送 TCP FIN 报文来关闭与 TCP 的通信。

**HTTPS 比 HTTP 慢 2 到 100 倍**

1. 通信慢：除去和 TCP 连接、发送 HTTP 请求/响应外，还必须进行 SSL 通信。
2. 消耗 CPU & 内存等资源：SSL 必须进行加密处理，在服务器和客户端都需要进行加密和解密的运算操作，导致负载增强。


**确认用户身份认证**

1. BASIC 认证（基本认证）
2. DIGEST 认证（摘要认证）
3. SSL 客户端认证
4. FormBase 认证（基于表单认证）